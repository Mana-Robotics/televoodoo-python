# WLAN Pose Streaming API (UDP + mDNS)

## Overview

Add Wi-Fi transport to Televoodoo Python as an alternative to BLE:

- **Discovery**: mDNS/Bonjour (`_televoodoo._udp.local.`)
- **Transport**: UDP (low latency, no connection overhead)
- **Data**: Binary packets (efficient, versioned)
- **Session**: Single-client exclusive lock with timeout

The iPhone app streams pose data **to** the Python server (iPhone → PC).

## Non-Goals

- No WAN/NAT traversal
- No guaranteed delivery (UDP drops acceptable)
- No TLS/DTLS (future consideration)
- No multi-client support

---

## CLI / Configuration

```bash
televoodoo --transport wlan [--wlan-port 50000] [--service-name MyRobot]
```

| Option | Default | Description |
|--------|---------|-------------|
| `--transport` | `auto` | `ble` or `wlan` |
| `--wlan-port` | `50000` | UDP port on PC |
| `--service-name` | `Televoodoo` | mDNS service instance name |

The existing `name` and `code` parameters from BLE are reused for identification and authentication.

---

## mDNS Service Advertisement

### Service Type
```
_televoodoo._udp.local.
```

### Instance Name
```
{service_name} @ {hostname}._televoodoo._udp.local.
```

### TXT Records

| Key | Example | Description |
|-----|---------|-------------|
| `v` | `1` | Protocol version |
| `port` | `50000` | UDP port for all traffic |
| `name` | `MyRobot` | Display name |

### Python Library
Use `zeroconf` for mDNS (cross-platform, well-maintained).

---

## Binary Protocol

All messages use **little-endian** byte order (native to ARM/x86, more efficient).

### Common Header (6 bytes)

| Offset | Field | Type | Description |
|--------|-------|------|-------------|
| 0 | `magic` | `char[4]` | `"TELE"` |
| 4 | `msg_type` | `uint8` | Message type ID |
| 5 | `version` | `uint8` | Protocol version (`1`) |

### Message Types

| ID | Name | Direction |
|----|------|-----------|
| 1 | HELLO | iPhone → PC |
| 2 | ACK | PC → iPhone |
| 3 | POSE | iPhone → PC |
| 4 | BYE | iPhone → PC |
| 5 | CMD | iPhone → PC |

---

## Session Lifecycle

### Single-Client Exclusivity

Only one client session at a time. While a session is active:
- HELLO from same `(src_ip, src_port)` = keepalive (update `last_seen_ts`)
- HELLO from different client = rejected with `ACK(status=BUSY)`
- Any valid packet from active client refreshes `last_seen_ts`

### Bidirectional Liveness Detection

Both sides must detect disconnects within **3 seconds**.

| Direction | Mechanism | Timeout |
|-----------|-----------|---------|
| iPhone → PC | Any packet (POSE, HELLO, CMD) refreshes `last_seen_ts` | 3 seconds |
| PC → iPhone | PC sends ACK in response to every HELLO | 3 seconds |

**Requirements:**
- iPhone **must** send HELLO at **1 Hz minimum**, even while streaming poses
- PC **must** respond with ACK to every HELLO (not just the first one)
- If iPhone receives no ACK for 3 seconds → PC disconnected
- If PC receives no packets for 3 seconds → iPhone disconnected

This approach reuses existing messages (no new message types needed).

---

## Message Formats

### HELLO (iPhone → PC)

Establishes or refreshes session.

| Offset | Field | Type | Bytes |
|--------|-------|------|-------|
| 0 | header | - | 6 |
| 6 | session_id | `uint32` | 4 |
| 10 | code | `char[6]` | 6 |
| 16 | reserved | `uint16` | 2 |
| **Total** | | | **18** |

- `session_id`: Random 32-bit value generated by client at connection start (helps detect reconnects)
- `code`: 6-character authentication code (same as BLE)

### ACK (PC → iPhone)

**Required response** to every HELLO (enables iPhone-side disconnect detection).

| Offset | Field | Type | Bytes |
|--------|-------|------|-------|
| 0 | header | - | 6 |
| 6 | status | `uint8` | 1 |
| 7 | reserved | `uint8` | 1 |
| **Total** | | | **8** |

Status codes:
- `0` = OK (session established/refreshed)
- `1` = BAD_CODE (authentication failed)
- `2` = BUSY (another client is connected)
- `3` = VERSION_UNSUPPORTED

**Liveness**: iPhone monitors ACK responses. If no ACK received for 3 seconds, the PC is considered disconnected.

### POSE (iPhone → PC)

Core pose data packet.

| Offset | Field | Type | Bytes |
|--------|-------|------|-------|
| 0 | header | - | 6 |
| 6 | seq | `uint16` | 2 |
| 8 | timestamp_us | `uint64` | 8 |
| 16 | flags | `uint8` | 1 |
| 17 | reserved | `uint8` | 1 |
| 18 | x | `float32` | 4 |
| 22 | y | `float32` | 4 |
| 26 | z | `float32` | 4 |
| 30 | qx | `float32` | 4 |
| 34 | qy | `float32` | 4 |
| 38 | qz | `float32` | 4 |
| 42 | qw | `float32` | 4 |
| **Total** | | | **46** |

#### Flags Bitfield

| Bit | Name | Description |
|-----|------|-------------|
| 0 | `movement_start` | New movement origin (reset deltas) |
| 1-7 | reserved | Must be 0 |

#### Timestamp

`timestamp_us` is **monotonic microseconds** since session start (first HELLO). This allows:
- Latency measurement
- Packet ordering
- Drop detection via `seq` gaps

#### Python Struct

```python
POSE_FORMAT = "<4sBBHQBB7f"  # little-endian, 46 bytes
```

### BYE (iPhone → PC)

Explicit session close (optional but recommended).

| Offset | Field | Type | Bytes |
|--------|-------|------|-------|
| 0 | header | - | 6 |
| 6 | session_id | `uint32` | 4 |
| **Total** | | | **10** |

Server behavior:
- If from active client with matching `session_id`: close session immediately
- Otherwise: ignore

### CMD (iPhone → PC)

Command signals (recording, etc.).

| Offset | Field | Type | Bytes |
|--------|-------|------|-------|
| 0 | header | - | 6 |
| 6 | cmd_type | `uint8` | 1 |
| 7 | value | `uint8` | 1 |
| **Total** | | | **8** |

Command types:
- `1` = RECORDING: value `1`=start, `0`=stop
- `2` = KEEP_RECORDING: value `1`=keep, `0`=discard

---

## Callback Event Format

WLAN events use the same format as BLE for compatibility:

```python
# Pose event
{
    "type": "pose",
    "data": {
        "absolute_input": {
            "movement_start": True,
            "x": 0.1, "y": 0.2, "z": 0.05,
            "qx": 0.0, "qy": 0.0, "qz": 0.0, "qw": 1.0,
            # Note: x_rot, y_rot, z_rot computed from quaternion if needed
        }
    }
}

# Command event  
{"type": "command", "name": "recording", "value": True}

# Connection events
{"type": "wlan_connected", "client": "192.168.1.50:51234"}
{"type": "wlan_disconnected", "reason": "timeout"}  # or "bye"
```

---

## Implementation Architecture

```
┌─────────────────────────────────────────────┐
│  Main Thread                                │
│  - Start mDNS advertisement                 │
│  - Print QR code / session info             │
│  - Block until shutdown                     │
└─────────────────────────────────────────────┘
                    │
    ┌───────────────┴───────────────┐
    ▼                               ▼
┌──────────────────┐    ┌──────────────────┐
│  UDP Receiver    │    │  Session Manager │
│  (thread/async)  │    │  - Track client  │
│  - Recv packets  │───▶│  - Check timeout │
│  - Parse + route │    │  - Emit events   │
└──────────────────┘    └──────────────────┘
```

### Socket Setup

```python
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(("0.0.0.0", port))
```

### Performance Guidelines

- Non-blocking receive loop (select/poll or asyncio)
- O(1) packet parsing (fixed offsets, no allocations)
- Minimal logging on pose path (rate-limit or quiet mode)
- Latest-wins: if receiver is behind, process only newest pose

---

## Startup Logging

```
[televoodoo] WLAN server starting...
[televoodoo] Service: MyRobot @ macbook.local._televoodoo._udp.local.
[televoodoo] UDP port: 50000
[televoodoo] IP: 192.168.1.100
[televoodoo] Code: ABC123
[televoodoo] Waiting for connection...
```

---

## Error Handling

| Condition | Behavior |
|-----------|----------|
| Malformed packet | Drop silently (log in debug mode) |
| Wrong magic/version | Drop silently |
| Wrong code in HELLO | Send `ACK(status=BAD_CODE)` |
| Second client HELLO | Send `ACK(status=BUSY)` |
| Packet from non-active client | Drop silently |

---

## Test Plan

1. **Unit tests**
   - Struct pack/unpack roundtrip for all message types
   - Session state machine transitions

2. **Integration test**
   - Mock UDP client → server on localhost
   - Verify HELLO/ACK handshake
   - Verify POSE packets trigger callbacks
   - Verify timeout closes session
   - Verify second client rejected

3. **LAN test**
   - Real iPhone app → Python on same network
   - mDNS discovery works
   - 60 Hz streaming stable
   - Latency < 10ms typical

---

## Changes from v1 Spec

| Change | Rationale |
|--------|-----------|
| Magic `"TELE"` instead of `"POSE"` | Clearer protocol identification |
| Little-endian byte order | Native to ARM/x86, more efficient |
| Fixed 6-char code | Matches BLE, simpler parsing |
| Added `session_id` | Detect reconnects from same IP:port |
| ACK is required, not optional | Clients need status feedback |
| ACK sent for every HELLO | Enables iPhone-side disconnect detection |
| Added CMD message | Parity with BLE command characteristic |
| Added `movement_start` flag | Required by existing Pose dataclass |
| Explicit `flags` field | Extensible without version bump |
| Timestamp = monotonic since session | Clear semantics, no ambiguity |
| Timeout reduced to 3 seconds | Faster disconnect detection both directions |
| Bidirectional liveness | Both sides detect disconnect within 3s |
